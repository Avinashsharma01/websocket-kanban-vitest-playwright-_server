# server.js Documentation

This document provides a detailed explanation of the `server.js` file, which is the core backend component of the WebSocket-powered Kanban board application.

## 🔍 Overview

The `server.js` file implements a WebSocket server using Express and Socket.IO to enable real-time communication between clients and the server. It manages task data in memory and provides endpoints for task management operations including creation, updating, moving, and deletion.

## 📋 Core Technologies

- **Express**: Web server framework for Node.js
- **HTTP**: Node.js built-in HTTP module to create the server
- **Socket.IO**: Real-time bidirectional event-based communication library

## 🏗️ Server Setup

```javascript
const express = require("express");
const http = require("http");
const { Server } = require("socket.io");

const app = express();
const server = http.createServer(app);
const io = new Server(server, { 
  cors: { 
    origin: "*",
    methods: ["GET", "POST"],
    allowedHeaders: ["Content-Type"]
  } 
});
```

The server setup involves:

1. Importing required modules: Express, HTTP, and Socket.IO
2. Creating an Express application
3. Creating an HTTP server using the Express app
4. Initializing Socket.IO with the HTTP server
5. Configuring CORS to allow cross-origin requests from any origin

## 💾 Data Structure

```javascript
// In-memory storage for tasks
const tasks = {
  todo: [],
  inProgress: [],
  done: []
};
```

The server uses a simple in-memory data structure to store tasks, organized into three columns:
- `todo`: Tasks that need to be done
- `inProgress`: Tasks currently being worked on
- `done`: Completed tasks

## 🛠️ Utility Functions

```javascript
// Generate a unique ID for tasks
const generateId = () => Math.random().toString(36).substring(2, 9);
```

A utility function that generates a random string to use as a unique ID for tasks. It:
1. Creates a random number with `Math.random()`
2. Converts it to a base-36 string (alphanumeric)
3. Takes a substring to get a shorter ID

## 🔄 WebSocket Connection Handling

```javascript
io.on("connection", (socket) => {
  console.log("A user connected");

  // Send all tasks to newly connected client
  socket.emit("sync:tasks", tasks);

  // Other event handlers...

  socket.on("disconnect", () => {
    console.log("User disconnected");
  });
});
```

When a new client connects to the WebSocket server:
1. The connection is logged to the console
2. The current state of all tasks is sent to the client using the `sync:tasks` event
3. Event listeners are set up for the client
4. When the client disconnects, it's logged to the console

## 📋 Task Event Handlers

### Task Creation

```javascript
socket.on("task:create", (taskData) => {
  const column = taskData.column || "todo";
  const newTask = {
    id: generateId(),
    title: taskData.title,
    description: taskData.description,
    priority: taskData.priority || "Medium",
    category: taskData.category || "Feature",
    attachments: taskData.attachments || [],
    createdAt: new Date().toISOString()
  };
  
  tasks[column].push(newTask);
  io.emit("task:created", { column, task: newTask });
  console.log(`Task created: ${newTask.title} in ${column}`);
});
```

When a client emits a `task:create` event:
1. The server assigns a default column (`todo`) if not specified
2. A new task object is created with:
   - A unique ID generated by the `generateId()` function
   - The provided task data (title, description)
   - Default values for missing properties (priority, category, attachments)
   - A timestamp for when the task was created
3. The new task is added to the specified column's array
4. A `task:created` event is broadcast to all connected clients
5. A log message is printed to the console

### Task Update

```javascript
socket.on("task:update", (updatedTask) => {
  const { id, column } = updatedTask;
  
  for (const col in tasks) {
    const taskIndex = tasks[col].findIndex(task => task.id === id);
    if (taskIndex !== -1) {
      tasks[col][taskIndex] = { ...tasks[col][taskIndex], ...updatedTask };
      io.emit("task:updated", { column: col, task: tasks[col][taskIndex] });
      console.log(`Task updated: ${tasks[col][taskIndex].title}`);
      break;
    }
  }
});
```

When a client emits a `task:update` event:
1. The server extracts the task ID and column from the updated task data
2. It searches for the task in all columns using the ID
3. When found, it updates the task object by:
   - Creating a new object that spreads the existing task properties
   - Overlaying the updated properties from the request
4. A `task:updated` event is broadcast to all connected clients
5. A log message is printed to the console
6. The search stops once the task is found and updated

### Task Movement

```javascript
socket.on("task:move", ({ taskId, sourceColumn, targetColumn }) => {
  const taskIndex = tasks[sourceColumn].findIndex(task => task.id === taskId);
  
  if (taskIndex !== -1) {
    const [movedTask] = tasks[sourceColumn].splice(taskIndex, 1);
    tasks[targetColumn].push(movedTask);
    
    io.emit("task:moved", {
      taskId,
      sourceColumn,
      targetColumn,
      task: movedTask
    });
    console.log(`Task moved: ${movedTask.title} from ${sourceColumn} to ${targetColumn}`);
  }
});
```

When a client emits a `task:move` event:
1. The server finds the task in the source column by its ID
2. If found, it removes the task from the source column using `splice()`
   - `splice()` returns an array of removed elements, which is destructured to get the task
3. It adds the task to the target column
4. A `task:moved` event is broadcast to all connected clients with:
   - The task ID
   - The source column
   - The target column
   - The complete task object
5. A log message is printed to the console

### Task Deletion

```javascript
socket.on("task:delete", ({ taskId, column }) => {
  const taskIndex = tasks[column].findIndex(task => task.id === taskId);
  
  if (taskIndex !== -1) {
    const [deletedTask] = tasks[column].splice(taskIndex, 1);
    io.emit("task:deleted", { taskId, column });
    console.log(`Task deleted: ${deletedTask.title} from ${column}`);
  }
});
```

When a client emits a `task:delete` event:
1. The server finds the task in the specified column by its ID
2. If found, it removes the task from the column using `splice()`
   - The removed task is stored in `deletedTask` for logging purposes
3. A `task:deleted` event is broadcast to all connected clients with:
   - The task ID
   - The column from which it was deleted
4. A log message is printed to the console

## 🚀 Server Startup

```javascript
server.listen(5000, () => console.log("Server running on port 5000"));
```

The server is configured to:
1. Listen on port 5000
2. Log a message to the console when it starts successfully

## 🔍 Event Flow Diagram

```
Client                                    Server
  |                                         |
  |------- Connection Established --------->|
  |<--------- sync:tasks (all data) --------|
  |                                         |
  |----------- task:create --------------->|
  |                                         | -- Add to in-memory storage
  |<--------- task:created (broadcast) -----|
  |                                         |
  |----------- task:update --------------->|
  |                                         | -- Update in-memory storage
  |<--------- task:updated (broadcast) -----|
  |                                         |
  |----------- task:move ---------------->|
  |                                         | -- Move in in-memory storage
  |<--------- task:moved (broadcast) -------|
  |                                         |
  |----------- task:delete --------------->|
  |                                         | -- Remove from in-memory storage
  |<--------- task:deleted (broadcast) -----|
  |                                         |
  |-------- Disconnection ---------------|
```

## 🧩 Key Implementation Details

1. **In-Memory Storage**: The server uses a simple in-memory JavaScript object to store task data, which is lost when the server restarts.

2. **Broadcast vs. Single Emit**: 
   - `socket.emit()` is used to send data to a specific client (used for initial sync)
   - `io.emit()` is used to broadcast events to all connected clients

3. **Error Handling**: The server implements basic error handling by checking if tasks exist before attempting to modify them.

4. **Default Values**: The server provides default values for task properties when they are not specified in the request.

5. **Immutability Pattern**: The server uses the spread operator (`...`) to create new objects when updating tasks, following React's immutability patterns.

## 🔒 Security Considerations

1. **CORS Configuration**: The server allows requests from any origin (`"*"`), which is acceptable for development but should be restricted in production.

2. **No Authentication**: The server does not implement authentication, allowing any client to connect and modify tasks.

3. **No Input Validation**: The server does not validate input data, which could lead to issues if clients send malformed data.

## 🔄 Scaling Considerations

For a production environment, consider:

1. **Persistent Storage**: Replace the in-memory storage with a database (MongoDB, PostgreSQL, etc.)

2. **Authentication**: Implement user authentication and authorization

3. **Input Validation**: Add validation for incoming data

4. **Error Handling**: Implement more robust error handling

5. **Multiple Servers**: Use Socket.IO's Redis adapter for multi-server setups

## 📊 Task Data Schema

Each task follows this structure:

```javascript
{
  id: "abc123",                  // Unique identifier
  title: "Implement login",      // Task title
  description: "Create login form and authentication", // Task description
  priority: "High",              // Priority level (Low, Medium, High)
  category: "Feature",           // Category (Bug, Feature, Enhancement)
  attachments: [                 // Array of attachments
    {
      name: "mockup.png",
      type: "image/png",
      url: "data:image/png;base64,...",
      size: 12345
    }
  ],
  createdAt: "2023-06-15T12:34:56.789Z" // ISO timestamp
}
```

## 🔍 Conclusion

The `server.js` file provides a straightforward implementation of a WebSocket server for a Kanban board application. It handles all the real-time communication between clients, manages task data in memory, and broadcasts updates to all connected clients. While suitable for development and demonstration purposes, it would need enhancements for a production environment, particularly in terms of data persistence, security, and scalability. 